package main

// 1. 创建切片
//func main() {
//	// 方式一
//	var s[] int
//	fmt.Println(len(s))
//
//	// 方式二
//	s2 := [] int {}
//	fmt.Println(s2)
//
//	//方式三: make函数
//	s3 := make([]int, 3, 5) // 长度为3， 容量是5, 长度不能大于容量。容量是可以省略的， 省略即长度等于容量。
//	fmt.Println(s3) //执行结果；[0 0 0]
//	fmt.Println(cap(s3)) //cap显示切片的容易， 执行结果为: 5
//
//	//使用make()函数创建注意:
//	// make(切片类型，长度， 容量)
//	// 长度是已经初始化的空间， 容量是已经开辟的空间， 包括已经初始化的空间和空闲的空间。
//	// 在使用make()函数定义切片时， 一定要注意， 切片长度要小于容量。
//	// len()函数返回长度，cap()函数返回容量
//	// make()函数中的容量参数是可以省略掉的， 这时容量与长度是相等的。
//}

// 2. 切片初始化
//func main() {

// 方式一
/*
	var s[] int
	s = append(s, 1,2,3,4,5)
	s = append(s, 80,90)
	s[3] = 88 // 修改下标3的元素为88
	fmt.Println(s) // 执行结果；[1 2 3 4 5 80 90]
*/

// 方式二
/*
	s := []int{1,2,3,4,5} // 初始化添加值。
	s = append(s, 88, 99) // 使用append方法追回元素。
	fmt.Println(s)
*/

// 方式三
/*
	s := make([] int, 3, 10)
	s[0] = 10
	s[1] = 20
	s[2] = 30
	s[3] = 40 // 下标3赋值会报越界错误， 因为下标3不存在。。

	s = append(s, 80) // 下标3的元素追加一个80
	fmt.Println(s)
*/
//}

// 3. 切片遍历

// 方法一: for...len
// 方法二: for...range

// 4. 切片截取

//func main() {
//	s := [] int {1,2,3,4,5,6}

/*

	//第一个值: 起始位置
	//第二个值: 结束位置
	//第三个值: 用来计算容量，容量指的是切片中最多能够容纳多少元素
	//容量=第三个值减去第一个值
	//长度=第二个值减去第一个值
	//容量的数值必须大于第二个值
	s1 := s[0:3:5]
	//s2 := s[1:6:5] // 由于容量5数值小于第二个数值6, 报语法错误。
	fmt.Println(s1)

*/

//s1 := s[:] //截取所有s的元素，相当于复制。
//s1 := s[3:] // 截取下标为3开始的元素。
//s1 := s[:3] //截取到下标为3的元素, 长度为3， 容量为6.  算法: s[0:3:6], 6减去0还得6. 此处6的容量默认省去了。 6的容量是由s带过来的。
//}

// 5. 切片值的修改
/*
注意: 切片截取后返回新切片 ，对新切片的值进行修改， 会影响原切片

func main() {
	s := []int{1,2,3,4,5,6,7,8}
	s1 := s[3:5]
	fmt.Println(s1) // 执行结果: [4 5]
	s1[0] = 88
	fmt.Println(s) //执行结果: [1 2 3 88 5 6 7 8], 此处下标为3的元素，变量为88
}

*/

// 6. 切片作为函数参数
/*

func main() {
	s := []int{1,2,3,4,5}
	Init(s)

}

func Init(number [] int)  {
	for i:=0; i<len(number);i++  {
		fmt.Println(number[i])
	}
}

*/

// 7. 在函数中修改切片的值，会影响原切片

/*

func main() {
	s := make([]int, 5, 10)
	Init(s)
	fmt.Println(s)

}

func Init(number [] int) {
	for i := 0; i < len(number); i++ {
		number[i] = i
	}
}

*/

func main() {
	//var s [] int = []int{1,2,3,4,5}
	//fmt.Println(s)

	//s := []int{1, 2, 3, 4, 5}
	//fmt.Println(s)

	//s := make([]int, 5, 10)
	//s = append(s,1,2,3,4,5)
	//fmt.Println(s)



}
